# P0.1 Infrastructure & DevOps Foundation - Design Document

> **Status**: Approved
> **Created**: 2026-01-18
> **Phase**: P0.1

---

## Overview

This document describes the infrastructure foundation for Groundwork, covering project structure, configuration, database setup, Docker, CI/CD, and testing infrastructure.

---

## Decisions Summary

| Decision | Choice |
|----------|--------|
| Package manager | uv |
| Project layout | src layout |
| Module organization | Domain-based |
| Database | PostgreSQL + asyncpg (fully async) |
| Test isolation | Transaction rollback |
| Docker | Full containerized with hot-reload |
| CI/CD | Full pipeline (lint, types, tests, coverage, Docker push) |
| Container registry | GitHub Container Registry |
| Pre-commit | Comprehensive (Ruff + mypy) |
| Logging | Structured JSON |
| Health endpoints | Detailed with metrics |
| Python version | 3.12 |

---

## Project Structure

```
groundwork/
├── src/
│   └── groundwork/
│       ├── __init__.py
│       ├── main.py              # FastAPI app factory
│       ├── core/
│       │   ├── __init__.py
│       │   ├── config.py        # Pydantic Settings (singleton)
│       │   ├── database.py      # Async engine, session factory
│       │   ├── logging.py       # Structured JSON logging setup
│       │   ├── middleware.py    # Request ID, timing, CORS
│       │   └── exceptions.py    # Global exception handlers
│       └── health/
│           ├── __init__.py
│           ├── routes.py        # /health/live, /health/ready, /health/details
│           └── services.py      # Health check logic
├── tests/
│   ├── conftest.py              # Fixtures: db session, test client
│   ├── factories/               # Factory Boy factories
│   └── health/
│       └── test_routes.py
├── alembic/
│   ├── env.py
│   └── versions/
├── docker/
│   ├── Dockerfile
│   └── docker-compose.yml
├── .github/
│   └── workflows/
│       └── ci.yml
├── pyproject.toml
├── alembic.ini
├── .pre-commit-config.yaml
├── .env.example
└── .gitignore
```

---

## Configuration & Settings

```python
# src/groundwork/core/config.py
from functools import lru_cache
from pydantic import PostgresDsn, field_validator
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )

    # Application
    app_name: str = "Groundwork"
    debug: bool = False
    environment: str = "development"  # development, staging, production

    # Database
    database_url: PostgresDsn
    db_pool_size: int = 5
    db_max_overflow: int = 10

    # Security
    secret_key: str
    access_token_expire_minutes: int = 30

    # Logging
    log_level: str = "INFO"
    log_json: bool = True  # JSON in prod, can disable for local dev

@lru_cache
def get_settings() -> Settings:
    return Settings()
```

### Environment Variables (.env.example)

```bash
DATABASE_URL=postgresql+asyncpg://groundwork:groundwork@db:5432/groundwork
SECRET_KEY=change-me-in-production
ENVIRONMENT=development
DEBUG=true
LOG_LEVEL=DEBUG
```

---

## Database Setup

```python
# src/groundwork/core/database.py
from collections.abc import AsyncGenerator
from sqlalchemy.ext.asyncio import (
    AsyncSession,
    async_sessionmaker,
    create_async_engine,
)
from sqlalchemy.orm import DeclarativeBase

from groundwork.core.config import get_settings

settings = get_settings()

engine = create_async_engine(
    str(settings.database_url),
    pool_size=settings.db_pool_size,
    max_overflow=settings.db_max_overflow,
    echo=settings.debug,
)

async_session_factory = async_sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

class Base(DeclarativeBase):
    """Base class for all models with common columns."""
    pass

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """Dependency for FastAPI routes."""
    async with async_session_factory() as session:
        try:
            yield session
            await session.commit()
        except Exception:
            await session.rollback()
            raise
```

---

## FastAPI App Factory

```python
# src/groundwork/main.py
import uuid
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware

from groundwork.core.config import get_settings
from groundwork.core.logging import setup_logging, get_logger
from groundwork.core.database import engine
from groundwork.health.routes import router as health_router

settings = get_settings()
logger = get_logger(__name__)

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Startup and shutdown events."""
    logger.info("Starting Groundwork", version=app.version)
    yield
    await engine.dispose()
    logger.info("Shutting down Groundwork")

def create_app() -> FastAPI:
    setup_logging()

    app = FastAPI(
        title=settings.app_name,
        version="0.1.0",
        lifespan=lifespan,
        docs_url="/docs" if settings.debug else None,
        redoc_url="/redoc" if settings.debug else None,
    )

    # Middleware (order matters - first added = outermost)
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"] if settings.debug else [],
        allow_methods=["*"],
        allow_headers=["*"],
    )

    @app.middleware("http")
    async def request_context(request: Request, call_next):
        request_id = request.headers.get("X-Request-ID", str(uuid.uuid4()))
        request.state.request_id = request_id
        response = await call_next(request)
        response.headers["X-Request-ID"] = request_id
        return response

    # Routes
    app.include_router(health_router, prefix="/health", tags=["health"])

    return app

app = create_app()
```

---

## Structured JSON Logging

```python
# src/groundwork/core/logging.py
import logging
import sys
from typing import Any
import json
from datetime import datetime, timezone

from groundwork.core.config import get_settings

class JSONFormatter(logging.Formatter):
    """Format log records as JSON."""

    def format(self, record: logging.LogRecord) -> str:
        log_data: dict[str, Any] = {
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "level": record.levelname,
            "logger": record.name,
            "message": record.getMessage(),
        }

        # Include request_id if available
        if hasattr(record, "request_id"):
            log_data["request_id"] = record.request_id

        # Include extra fields
        if hasattr(record, "__dict__"):
            for key, value in record.__dict__.items():
                if key not in ("name", "msg", "args", "created", "filename",
                              "funcName", "levelname", "levelno", "lineno",
                              "module", "msecs", "pathname", "process",
                              "processName", "relativeCreated", "stack_info",
                              "exc_info", "exc_text", "thread", "threadName",
                              "taskName", "message", "request_id"):
                    log_data[key] = value

        if record.exc_info:
            log_data["exception"] = self.formatException(record.exc_info)

        return json.dumps(log_data)

def setup_logging() -> None:
    settings = get_settings()

    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(JSONFormatter())

    logging.basicConfig(
        level=getattr(logging, settings.log_level.upper()),
        handlers=[handler],
    )

    # Quiet noisy libraries
    logging.getLogger("uvicorn.access").setLevel(logging.WARNING)

def get_logger(name: str) -> logging.Logger:
    return logging.getLogger(name)
```

---

## Health Check Endpoints

```python
# src/groundwork/health/routes.py
from fastapi import APIRouter, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text

from groundwork.core.database import get_db
from groundwork.health.services import HealthService

router = APIRouter()

@router.get("/live")
async def liveness():
    """App is running. Used by Kubernetes liveness probe."""
    return {"status": "ok"}

@router.get("/ready")
async def readiness(db: AsyncSession = Depends(get_db)):
    """App is ready to serve traffic. Checks dependencies."""
    service = HealthService(db)
    is_ready = await service.check_readiness()
    if not is_ready:
        return {"status": "unavailable"}, 503
    return {"status": "ok"}

@router.get("/details")
async def details(db: AsyncSession = Depends(get_db)):
    """Detailed health with component status and metrics."""
    service = HealthService(db)
    return await service.get_details()
```

```python
# src/groundwork/health/services.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from groundwork.core.config import get_settings

class HealthService:
    def __init__(self, db: AsyncSession):
        self.db = db
        self.settings = get_settings()

    async def check_readiness(self) -> bool:
        try:
            await self.db.execute(text("SELECT 1"))
            return True
        except Exception:
            return False

    async def get_details(self) -> dict:
        db_ok = await self.check_readiness()
        return {
            "status": "ok" if db_ok else "degraded",
            "version": "0.1.0",
            "environment": self.settings.environment,
            "components": {
                "database": {"status": "ok" if db_ok else "unavailable"},
            },
        }
```

---

## Docker Setup

### Dockerfile

```dockerfile
# docker/Dockerfile
FROM python:3.12-slim AS base

ENV PYTHONDONTWRITEBYTECODE=1 \
    PYTHONUNBUFFERED=1 \
    UV_SYSTEM_PYTHON=1

WORKDIR /app

# Install uv
RUN pip install uv

# Dependencies layer (cached unless pyproject.toml changes)
COPY pyproject.toml uv.lock* ./
RUN uv sync --frozen --no-dev

# Production image
FROM base AS production
COPY src/ ./src/
COPY alembic/ ./alembic/
COPY alembic.ini ./
CMD ["uv", "run", "uvicorn", "groundwork.main:app", "--host", "0.0.0.0", "--port", "8000"]

# Development image
FROM base AS development
RUN uv sync --frozen
CMD ["uv", "run", "uvicorn", "groundwork.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]
```

### Docker Compose

```yaml
# docker/docker-compose.yml
services:
  db:
    image: postgres:16
    environment:
      POSTGRES_USER: groundwork
      POSTGRES_PASSWORD: groundwork
      POSTGRES_DB: groundwork
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U groundwork"]
      interval: 5s
      timeout: 5s
      retries: 5

  app:
    build:
      context: ..
      dockerfile: docker/Dockerfile
      target: development
    volumes:
      - ../src:/app/src
      - ../tests:/app/tests
    ports:
      - "8000:8000"
    depends_on:
      db:
        condition: service_healthy
    env_file:
      - ../.env

volumes:
  postgres_data:
```

---

## Testing Infrastructure

```python
# tests/conftest.py
import pytest
from httpx import ASGITransport, AsyncClient
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker

from groundwork.main import create_app
from groundwork.core.database import Base, get_db
from groundwork.core.config import get_settings

settings = get_settings()

# Test database engine
test_engine = create_async_engine(
    str(settings.database_url),
    echo=False,
)
test_session_factory = async_sessionmaker(
    test_engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

@pytest.fixture(scope="session")
def anyio_backend():
    return "asyncio"

@pytest.fixture(scope="session")
async def setup_database():
    """Create tables once per test session."""
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)
    yield
    async with test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)

@pytest.fixture
async def db_session(setup_database) -> AsyncSession:
    """Transaction-wrapped session that rolls back after each test."""
    async with test_engine.connect() as conn:
        await conn.begin()
        session = AsyncSession(bind=conn)
        yield session
        await session.close()
        await conn.rollback()

@pytest.fixture
async def client(db_session: AsyncSession):
    """Test client with overridden database dependency."""
    app = create_app()
    app.dependency_overrides[get_db] = lambda: db_session

    async with AsyncClient(
        transport=ASGITransport(app=app),
        base_url="http://test"
    ) as ac:
        yield ac
```

```python
# tests/health/test_routes.py
import pytest

@pytest.mark.anyio
async def test_liveness(client):
    response = await client.get("/health/live")
    assert response.status_code == 200
    assert response.json()["status"] == "ok"

@pytest.mark.anyio
async def test_readiness(client):
    response = await client.get("/health/ready")
    assert response.status_code == 200

@pytest.mark.anyio
async def test_details(client):
    response = await client.get("/health/details")
    assert response.status_code == 200
    data = response.json()
    assert "version" in data
    assert "components" in data
```

---

## CI/CD Pipeline

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v4
      - run: uv sync --frozen
      - run: uv run ruff check src tests
      - run: uv run ruff format --check src tests

  typecheck:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v4
      - run: uv sync --frozen
      - run: uv run mypy src

  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: groundwork
          POSTGRES_PASSWORD: groundwork
          POSTGRES_DB: groundwork_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    steps:
      - uses: actions/checkout@v4
      - uses: astral-sh/setup-uv@v4
      - run: uv sync --frozen
      - run: uv run pytest --cov=src --cov-report=xml
        env:
          DATABASE_URL: postgresql+asyncpg://groundwork:groundwork@localhost:5432/groundwork_test
          SECRET_KEY: test-secret-key
      - uses: codecov/codecov-action@v4
        with:
          files: coverage.xml

  build:
    needs: [lint, typecheck, test]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4
      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      - uses: docker/build-push-action@v5
        with:
          context: .
          file: docker/Dockerfile
          target: production
          push: true
          tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
```

---

## Pre-commit Hooks

```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v5.0.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
        args: ['--maxkb=1000']
      - id: check-merge-conflict
      - id: detect-private-key

  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.9.0
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format

  - repo: local
    hooks:
      - id: mypy
        name: mypy
        entry: uv run mypy src
        language: system
        types: [python]
        pass_filenames: false
```

---

## Dependencies (pyproject.toml)

```toml
[project]
name = "groundwork"
version = "0.1.0"
description = "Open source self-hosted project management"
readme = "README.md"
license = { text = "GPL-3.0" }
requires-python = ">=3.12"
dependencies = [
    "fastapi>=0.128.0",
    "uvicorn[standard]>=0.40.0",
    "pydantic>=2.12.5",
    "pydantic-settings>=2.7.0",
    "sqlalchemy[asyncio]>=2.0.45",
    "asyncpg>=0.30.0",
    "alembic>=1.14.0",
    "python-jose[cryptography]>=3.3.0",
    "passlib[argon2]>=1.7.4",
]

[project.optional-dependencies]
dev = [
    "pytest>=8.3.0",
    "pytest-asyncio>=0.25.0",
    "pytest-cov>=6.0.0",
    "httpx>=0.28.0",
    "factory-boy>=3.3.0",
    "ruff>=0.9.0",
    "mypy>=1.14.0",
    "pre-commit>=4.0.0",
]

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = ["src/groundwork"]

[tool.pytest.ini_options]
asyncio_mode = "auto"
testpaths = ["tests"]

[tool.ruff]
target-version = "py312"
line-length = 88
src = ["src", "tests"]

[tool.ruff.lint]
select = ["E", "F", "I", "UP", "B", "SIM", "ASYNC"]
ignore = ["E501"]

[tool.mypy]
python_version = "3.12"
strict = true
plugins = ["pydantic.mypy"]

[[tool.mypy.overrides]]
module = "tests.*"
disallow_untyped_defs = false
```

---

## Files to Create

- `pyproject.toml`
- `src/groundwork/__init__.py`
- `src/groundwork/main.py`
- `src/groundwork/core/__init__.py`
- `src/groundwork/core/config.py`
- `src/groundwork/core/database.py`
- `src/groundwork/core/logging.py`
- `src/groundwork/core/middleware.py`
- `src/groundwork/core/exceptions.py`
- `src/groundwork/health/__init__.py`
- `src/groundwork/health/routes.py`
- `src/groundwork/health/services.py`
- `tests/__init__.py`
- `tests/conftest.py`
- `tests/factories/__init__.py`
- `tests/health/__init__.py`
- `tests/health/test_routes.py`
- `docker/Dockerfile`
- `docker/docker-compose.yml`
- `.github/workflows/ci.yml`
- `.pre-commit-config.yaml`
- `alembic.ini`
- `alembic/env.py`
- `alembic/versions/.gitkeep`
- `.env.example`
