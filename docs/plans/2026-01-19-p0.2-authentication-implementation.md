# P0.2 Authentication Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement authentication, user management, RBAC, and setup wizard for Groundwork.

**Architecture:** Strategy pattern for auth providers (LocalAuthProvider now), JWT in HTTP-only cookies, full RBAC with custom roles, HTMX + Jinja2 UI.

**Tech Stack:** FastAPI, SQLAlchemy 2.0, Argon2, python-jose, Jinja2, HTMX

**Design Doc:** `docs/plans/2026-01-19-p0.2-authentication-design.md`

---

## Task 1: Auth Models - User, Role, Permission

**Files:**
- Create: `src/groundwork/auth/__init__.py`
- Create: `src/groundwork/auth/models.py`
- Create: `tests/auth/__init__.py`
- Create: `tests/auth/test_models.py`

**Step 1: Write the failing test**

Create `tests/auth/__init__.py`:
```python
"""Tests for auth module."""
```

Create `tests/auth/test_models.py`:
```python
"""Tests for auth models."""

import pytest
from sqlalchemy import select


@pytest.mark.asyncio
async def test_role_has_permission_returns_true_when_permission_exists(db_session) -> None:
    """Role.has_permission should return True when role has the permission."""
    from groundwork.auth.models import Permission, Role

    permission = Permission(codename="users:read", description="Can read users")
    role = Role(name="TestRole", description="Test role")
    role.permissions.append(permission)

    db_session.add(role)
    await db_session.commit()

    assert role.has_permission("users:read") is True
    assert role.has_permission("users:write") is False


@pytest.mark.asyncio
async def test_user_model_creates_with_role(db_session) -> None:
    """User should be created with a role."""
    from groundwork.auth.models import Role, User

    role = Role(name="Member", description="Regular member")
    db_session.add(role)
    await db_session.commit()

    user = User(
        email="test@example.com",
        hashed_password="hashed",
        first_name="Test",
        last_name="User",
        role_id=role.id,
    )
    db_session.add(user)
    await db_session.commit()

    result = await db_session.execute(select(User).where(User.email == "test@example.com"))
    fetched_user = result.scalar_one()

    assert fetched_user.first_name == "Test"
    assert fetched_user.role_id == role.id
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest tests/auth/test_models.py -v`
Expected: FAIL with ModuleNotFoundError

**Step 3: Write the implementation**

Create `src/groundwork/auth/__init__.py`:
```python
"""Authentication module."""
```

Create `src/groundwork/auth/models.py`:
```python
"""Authentication models."""

from datetime import datetime
from typing import TYPE_CHECKING
from uuid import uuid4

from sqlalchemy import ForeignKey, String, Table, Column, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column, relationship

from groundwork.core.database import Base

if TYPE_CHECKING:
    from collections.abc import Sequence

# Association table for Role <-> Permission many-to-many
role_permissions = Table(
    "role_permissions",
    Base.metadata,
    Column("role_id", UUID(as_uuid=True), ForeignKey("roles.id"), primary_key=True),
    Column("permission_id", UUID(as_uuid=True), ForeignKey("permissions.id"), primary_key=True),
)


class Permission(Base):
    """System permission."""

    __tablename__ = "permissions"

    id: Mapped[uuid4] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    codename: Mapped[str] = mapped_column(String(100), unique=True, index=True)
    description: Mapped[str] = mapped_column(String(500))

    roles: Mapped[list["Role"]] = relationship(
        secondary=role_permissions, back_populates="permissions"
    )


class Role(Base):
    """User role with permissions."""

    __tablename__ = "roles"

    id: Mapped[uuid4] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    name: Mapped[str] = mapped_column(String(100), unique=True)
    description: Mapped[str] = mapped_column(String(500))
    is_system: Mapped[bool] = mapped_column(default=False)
    created_at: Mapped[datetime] = mapped_column(default=func.now())

    users: Mapped[list["User"]] = relationship(back_populates="role")
    permissions: Mapped[list["Permission"]] = relationship(
        secondary=role_permissions, back_populates="roles"
    )

    def has_permission(self, codename: str) -> bool:
        """Check if role has a specific permission."""
        return any(p.codename == codename for p in self.permissions)


class User(Base):
    """Application user."""

    __tablename__ = "users"

    id: Mapped[uuid4] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    email: Mapped[str] = mapped_column(String(255), unique=True, index=True)
    hashed_password: Mapped[str] = mapped_column(String(255))
    first_name: Mapped[str] = mapped_column(String(100))
    last_name: Mapped[str] = mapped_column(String(100))
    display_name: Mapped[str | None] = mapped_column(String(200), nullable=True)
    avatar_path: Mapped[str | None] = mapped_column(String(500), nullable=True)
    is_active: Mapped[bool] = mapped_column(default=True)
    email_verified: Mapped[bool] = mapped_column(default=False)
    role_id: Mapped[uuid4] = mapped_column(UUID(as_uuid=True), ForeignKey("roles.id"))
    timezone: Mapped[str] = mapped_column(String(50), default="UTC")
    language: Mapped[str] = mapped_column(String(10), default="en")
    theme: Mapped[str] = mapped_column(String(20), default="system")
    created_at: Mapped[datetime] = mapped_column(default=func.now())
    updated_at: Mapped[datetime] = mapped_column(default=func.now(), onupdate=func.now())
    last_login_at: Mapped[datetime | None] = mapped_column(nullable=True)

    role: Mapped["Role"] = relationship(back_populates="users")

    @property
    def full_name(self) -> str:
        """Return user's full name."""
        return f"{self.first_name} {self.last_name}"
```

**Step 4: Update conftest.py for auth model tests**

The existing `tests/conftest.py` needs to import auth models so tables are created. Edit `tests/conftest.py` to add:
```python
# Add after other imports from groundwork
from groundwork.auth import models as auth_models  # noqa: F401
```

**Step 5: Run test to verify it passes**

Run: `uv run pytest tests/auth/test_models.py -v`
Expected: PASS (2 tests)

**Step 6: Run type check**

Run: `uv run mypy src/groundwork/auth/`
Expected: Success

**Step 7: Commit**

```bash
git add src/groundwork/auth/ tests/auth/
git commit -m "feat: add User, Role, Permission models"
```

---

## Task 2: RefreshToken and InstanceConfig Models

**Files:**
- Modify: `src/groundwork/auth/models.py`
- Create: `src/groundwork/setup/__init__.py`
- Create: `src/groundwork/setup/models.py`
- Create: `tests/auth/test_refresh_token.py`
- Create: `tests/setup/__init__.py`
- Create: `tests/setup/test_models.py`

**Step 1: Write the failing tests**

Create `tests/auth/test_refresh_token.py`:
```python
"""Tests for RefreshToken model."""

import pytest
from datetime import datetime, timedelta, timezone


@pytest.mark.asyncio
async def test_refresh_token_created_for_user(db_session) -> None:
    """RefreshToken should be created and linked to user."""
    from groundwork.auth.models import RefreshToken, Role, User

    role = Role(name="Member", description="Member role")
    db_session.add(role)
    await db_session.commit()

    user = User(
        email="test@example.com",
        hashed_password="hashed",
        first_name="Test",
        last_name="User",
        role_id=role.id,
    )
    db_session.add(user)
    await db_session.commit()

    token = RefreshToken(
        user_id=user.id,
        token_hash="hashed_token_value",
        expires_at=datetime.now(timezone.utc) + timedelta(days=7),
    )
    db_session.add(token)
    await db_session.commit()

    assert token.user_id == user.id
    assert token.revoked_at is None
```

Create `tests/setup/__init__.py`:
```python
"""Tests for setup module."""
```

Create `tests/setup/test_models.py`:
```python
"""Tests for setup models."""

import pytest


@pytest.mark.asyncio
async def test_instance_config_created(db_session) -> None:
    """InstanceConfig should store instance settings."""
    from groundwork.setup.models import InstanceConfig

    config = InstanceConfig(
        instance_name="Test Instance",
        base_url="http://localhost:8000",
    )
    db_session.add(config)
    await db_session.commit()

    assert config.setup_completed is False
    assert config.smtp_configured is False
```

**Step 2: Run tests to verify they fail**

Run: `uv run pytest tests/auth/test_refresh_token.py tests/setup/test_models.py -v`
Expected: FAIL

**Step 3: Write the implementation**

Add to `src/groundwork/auth/models.py` (after User class):
```python
class RefreshToken(Base):
    """Refresh token for session management."""

    __tablename__ = "refresh_tokens"

    id: Mapped[uuid4] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    user_id: Mapped[uuid4] = mapped_column(UUID(as_uuid=True), ForeignKey("users.id"))
    token_hash: Mapped[str] = mapped_column(String(255), index=True)
    expires_at: Mapped[datetime]
    revoked_at: Mapped[datetime | None] = mapped_column(nullable=True)
    created_at: Mapped[datetime] = mapped_column(default=func.now())

    user: Mapped["User"] = relationship()
```

Create `src/groundwork/setup/__init__.py`:
```python
"""Setup wizard module."""
```

Create `src/groundwork/setup/models.py`:
```python
"""Setup models."""

from datetime import datetime
from uuid import uuid4

from sqlalchemy import String, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import Mapped, mapped_column

from groundwork.core.database import Base


class InstanceConfig(Base):
    """Instance configuration and setup state."""

    __tablename__ = "instance_config"

    id: Mapped[uuid4] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    instance_name: Mapped[str] = mapped_column(String(200))
    base_url: Mapped[str] = mapped_column(String(500))
    setup_completed: Mapped[bool] = mapped_column(default=False)
    smtp_host: Mapped[str | None] = mapped_column(String(255), nullable=True)
    smtp_port: Mapped[int | None] = mapped_column(nullable=True)
    smtp_username: Mapped[str | None] = mapped_column(String(255), nullable=True)
    smtp_password: Mapped[str | None] = mapped_column(String(255), nullable=True)
    smtp_from_address: Mapped[str | None] = mapped_column(String(255), nullable=True)
    smtp_configured: Mapped[bool] = mapped_column(default=False)
    created_at: Mapped[datetime] = mapped_column(default=func.now())
    updated_at: Mapped[datetime] = mapped_column(default=func.now(), onupdate=func.now())
```

**Step 4: Update conftest.py**

Add to imports in `tests/conftest.py`:
```python
from groundwork.setup import models as setup_models  # noqa: F401
```

**Step 5: Run tests to verify they pass**

Run: `uv run pytest tests/auth/test_refresh_token.py tests/setup/test_models.py -v`
Expected: PASS (2 tests)

**Step 6: Run type check**

Run: `uv run mypy src/groundwork/auth/ src/groundwork/setup/`
Expected: Success

**Step 7: Commit**

```bash
git add src/groundwork/auth/ src/groundwork/setup/ tests/
git commit -m "feat: add RefreshToken and InstanceConfig models"
```

---

## Task 3: Alembic Migration for Auth Tables

**Files:**
- Create: `alembic/versions/001_add_auth_tables.py`

**Step 1: Generate migration**

Run: `uv run alembic revision --autogenerate -m "add auth tables"`

**Step 2: Review and edit migration**

The generated migration should create tables: permissions, roles, role_permissions, users, refresh_tokens, instance_config.

Verify the migration file looks correct.

**Step 3: Test migration (if database available)**

Run: `uv run alembic upgrade head`
Expected: Tables created

**Step 4: Commit**

```bash
git add alembic/versions/
git commit -m "feat: add migration for auth tables"
```

---

## Task 4: Password Hashing Utilities

**Files:**
- Create: `src/groundwork/auth/utils.py`
- Create: `tests/auth/test_utils.py`

**Step 1: Write the failing test**

Create `tests/auth/test_utils.py`:
```python
"""Tests for auth utilities."""

import pytest


def test_hash_password_returns_hashed_value() -> None:
    """hash_password should return a hashed string."""
    from groundwork.auth.utils import hash_password

    password = "mysecretpassword"
    hashed = hash_password(password)

    assert hashed != password
    assert hashed.startswith("$argon2")


def test_verify_password_returns_true_for_correct_password() -> None:
    """verify_password should return True for correct password."""
    from groundwork.auth.utils import hash_password, verify_password

    password = "mysecretpassword"
    hashed = hash_password(password)

    assert verify_password(password, hashed) is True
    assert verify_password("wrongpassword", hashed) is False
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest tests/auth/test_utils.py -v`
Expected: FAIL with ModuleNotFoundError

**Step 3: Write the implementation**

Create `src/groundwork/auth/utils.py`:
```python
"""Authentication utilities."""

from passlib.context import CryptContext

# Argon2 password hashing
pwd_context = CryptContext(schemes=["argon2"], deprecated="auto")


def hash_password(password: str) -> str:
    """Hash a password using Argon2."""
    return pwd_context.hash(password)


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash."""
    return pwd_context.verify(plain_password, hashed_password)
```

**Step 4: Run test to verify it passes**

Run: `uv run pytest tests/auth/test_utils.py -v`
Expected: PASS (2 tests)

**Step 5: Run type check**

Run: `uv run mypy src/groundwork/auth/utils.py`
Expected: Success

**Step 6: Commit**

```bash
git add src/groundwork/auth/utils.py tests/auth/test_utils.py
git commit -m "feat: add password hashing utilities with Argon2"
```

---

## Task 5: JWT Utilities

**Files:**
- Modify: `src/groundwork/auth/utils.py`
- Modify: `tests/auth/test_utils.py`

**Step 1: Write the failing test**

Add to `tests/auth/test_utils.py`:
```python
from datetime import timedelta
from uuid import uuid4


def test_create_access_token_returns_jwt() -> None:
    """create_access_token should return a valid JWT."""
    from groundwork.auth.utils import create_access_token, decode_token

    user_id = uuid4()
    token = create_access_token(user_id=str(user_id))

    assert token is not None
    payload = decode_token(token)
    assert payload["sub"] == str(user_id)
    assert payload["type"] == "access"


def test_create_refresh_token_returns_jwt() -> None:
    """create_refresh_token should return a valid JWT with longer expiry."""
    from groundwork.auth.utils import create_refresh_token, decode_token

    user_id = uuid4()
    token = create_refresh_token(user_id=str(user_id))

    payload = decode_token(token)
    assert payload["sub"] == str(user_id)
    assert payload["type"] == "refresh"


def test_decode_token_returns_none_for_invalid_token() -> None:
    """decode_token should return None for invalid tokens."""
    from groundwork.auth.utils import decode_token

    result = decode_token("invalid.token.here")
    assert result is None
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest tests/auth/test_utils.py::test_create_access_token_returns_jwt -v`
Expected: FAIL

**Step 3: Write the implementation**

Add to `src/groundwork/auth/utils.py`:
```python
from datetime import datetime, timedelta, timezone
from typing import Any

from jose import JWTError, jwt

from groundwork.core.config import get_settings

# JWT settings
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 15
REFRESH_TOKEN_EXPIRE_DAYS = 7


def create_access_token(user_id: str, expires_delta: timedelta | None = None) -> str:
    """Create a JWT access token."""
    settings = get_settings()
    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))
    payload = {
        "sub": user_id,
        "exp": expire,
        "type": "access",
    }
    return jwt.encode(payload, settings.secret_key, algorithm=ALGORITHM)


def create_refresh_token(user_id: str, expires_delta: timedelta | None = None) -> str:
    """Create a JWT refresh token."""
    settings = get_settings()
    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(days=REFRESH_TOKEN_EXPIRE_DAYS))
    payload = {
        "sub": user_id,
        "exp": expire,
        "type": "refresh",
    }
    return jwt.encode(payload, settings.secret_key, algorithm=ALGORITHM)


def decode_token(token: str) -> dict[str, Any] | None:
    """Decode and validate a JWT token."""
    settings = get_settings()
    try:
        payload = jwt.decode(token, settings.secret_key, algorithms=[ALGORITHM])
        return payload
    except JWTError:
        return None
```

**Step 4: Run test to verify it passes**

Run: `uv run pytest tests/auth/test_utils.py -v`
Expected: PASS (5 tests)

**Step 5: Run type check**

Run: `uv run mypy src/groundwork/auth/utils.py`
Expected: Success

**Step 6: Commit**

```bash
git add src/groundwork/auth/utils.py tests/auth/test_utils.py
git commit -m "feat: add JWT token utilities"
```

---

## Task 6: Auth Provider Base Class

**Files:**
- Create: `src/groundwork/auth/providers/__init__.py`
- Create: `src/groundwork/auth/providers/base.py`
- Create: `tests/auth/test_providers.py`

**Step 1: Write the failing test**

Create `tests/auth/test_providers.py`:
```python
"""Tests for auth providers."""

import pytest
from abc import ABC


def test_auth_provider_is_abstract() -> None:
    """AuthProvider should be an abstract base class."""
    from groundwork.auth.providers.base import AuthProvider

    assert issubclass(AuthProvider, ABC)

    with pytest.raises(TypeError):
        AuthProvider()  # Cannot instantiate abstract class
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest tests/auth/test_providers.py -v`
Expected: FAIL

**Step 3: Write the implementation**

Create `src/groundwork/auth/providers/__init__.py`:
```python
"""Authentication providers."""

from groundwork.auth.providers.base import AuthProvider

__all__ = ["AuthProvider"]
```

Create `src/groundwork/auth/providers/base.py`:
```python
"""Base authentication provider."""

from abc import ABC, abstractmethod
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from groundwork.auth.models import User


class AuthProvider(ABC):
    """Abstract base class for authentication providers."""

    @abstractmethod
    async def authenticate(self, email: str, password: str) -> "User | None":
        """Authenticate user with email and password.

        Returns User if credentials are valid, None otherwise.
        """
        ...

    @abstractmethod
    async def create_user(
        self,
        email: str,
        password: str,
        first_name: str,
        last_name: str,
        role_id: str,
    ) -> "User":
        """Create a new user."""
        ...

    @abstractmethod
    async def change_password(self, user: "User", new_password: str) -> None:
        """Change user's password."""
        ...

    @abstractmethod
    async def verify_email(self, user: "User") -> None:
        """Mark user's email as verified."""
        ...
```

**Step 4: Run test to verify it passes**

Run: `uv run pytest tests/auth/test_providers.py -v`
Expected: PASS

**Step 5: Run type check**

Run: `uv run mypy src/groundwork/auth/providers/`
Expected: Success

**Step 6: Commit**

```bash
git add src/groundwork/auth/providers/ tests/auth/test_providers.py
git commit -m "feat: add AuthProvider abstract base class"
```

---

## Task 7: Local Auth Provider

**Files:**
- Create: `src/groundwork/auth/providers/local.py`
- Modify: `src/groundwork/auth/providers/__init__.py`
- Modify: `tests/auth/test_providers.py`

**Step 1: Write the failing test**

Add to `tests/auth/test_providers.py`:
```python
from unittest.mock import AsyncMock, MagicMock
from uuid import uuid4


@pytest.mark.asyncio
async def test_local_auth_provider_authenticate_returns_user() -> None:
    """LocalAuthProvider.authenticate should return user for valid credentials."""
    from groundwork.auth.providers.local import LocalAuthProvider
    from groundwork.auth.utils import hash_password

    mock_session = AsyncMock()
    provider = LocalAuthProvider(mock_session)

    # Create a mock user
    mock_user = MagicMock()
    mock_user.hashed_password = hash_password("correctpassword")
    mock_user.is_active = True

    # Mock the query result
    mock_result = MagicMock()
    mock_result.scalar_one_or_none.return_value = mock_user
    mock_session.execute.return_value = mock_result

    result = await provider.authenticate("test@example.com", "correctpassword")

    assert result is mock_user


@pytest.mark.asyncio
async def test_local_auth_provider_authenticate_returns_none_for_wrong_password() -> None:
    """LocalAuthProvider.authenticate should return None for wrong password."""
    from groundwork.auth.providers.local import LocalAuthProvider
    from groundwork.auth.utils import hash_password

    mock_session = AsyncMock()
    provider = LocalAuthProvider(mock_session)

    mock_user = MagicMock()
    mock_user.hashed_password = hash_password("correctpassword")
    mock_user.is_active = True

    mock_result = MagicMock()
    mock_result.scalar_one_or_none.return_value = mock_user
    mock_session.execute.return_value = mock_result

    result = await provider.authenticate("test@example.com", "wrongpassword")

    assert result is None
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest tests/auth/test_providers.py::test_local_auth_provider_authenticate_returns_user -v`
Expected: FAIL

**Step 3: Write the implementation**

Create `src/groundwork/auth/providers/local.py`:
```python
"""Local authentication provider."""

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from groundwork.auth.models import User
from groundwork.auth.providers.base import AuthProvider
from groundwork.auth.utils import hash_password, verify_password


class LocalAuthProvider(AuthProvider):
    """Authentication provider using local database."""

    def __init__(self, db: AsyncSession) -> None:
        """Initialize with database session."""
        self.db = db

    async def authenticate(self, email: str, password: str) -> User | None:
        """Authenticate user with email and password."""
        result = await self.db.execute(
            select(User).where(User.email == email)
        )
        user = result.scalar_one_or_none()

        if user is None:
            return None

        if not user.is_active:
            return None

        if not verify_password(password, user.hashed_password):
            return None

        return user

    async def create_user(
        self,
        email: str,
        password: str,
        first_name: str,
        last_name: str,
        role_id: str,
    ) -> User:
        """Create a new user with hashed password."""
        from uuid import UUID

        user = User(
            email=email,
            hashed_password=hash_password(password),
            first_name=first_name,
            last_name=last_name,
            role_id=UUID(role_id),
        )
        self.db.add(user)
        await self.db.flush()
        return user

    async def change_password(self, user: User, new_password: str) -> None:
        """Change user's password."""
        user.hashed_password = hash_password(new_password)
        await self.db.flush()

    async def verify_email(self, user: User) -> None:
        """Mark user's email as verified."""
        user.email_verified = True
        await self.db.flush()
```

Update `src/groundwork/auth/providers/__init__.py`:
```python
"""Authentication providers."""

from groundwork.auth.providers.base import AuthProvider
from groundwork.auth.providers.local import LocalAuthProvider

__all__ = ["AuthProvider", "LocalAuthProvider"]
```

**Step 4: Run test to verify it passes**

Run: `uv run pytest tests/auth/test_providers.py -v`
Expected: PASS (3 tests)

**Step 5: Run type check**

Run: `uv run mypy src/groundwork/auth/providers/`
Expected: Success

**Step 6: Commit**

```bash
git add src/groundwork/auth/providers/ tests/auth/test_providers.py
git commit -m "feat: add LocalAuthProvider implementation"
```

---

## Task 8: Auth Schemas

**Files:**
- Create: `src/groundwork/auth/schemas.py`

**Step 1: Write the implementation**

Create `src/groundwork/auth/schemas.py`:
```python
"""Authentication Pydantic schemas."""

from datetime import datetime
from uuid import UUID

from pydantic import BaseModel, EmailStr, Field


# Request schemas
class LoginRequest(BaseModel):
    """Login request body."""

    email: EmailStr
    password: str = Field(min_length=8)


class PasswordResetRequest(BaseModel):
    """Password reset request."""

    email: EmailStr


class PasswordResetConfirm(BaseModel):
    """Password reset confirmation."""

    token: str
    new_password: str = Field(min_length=8)


class ChangePasswordRequest(BaseModel):
    """Change password request."""

    current_password: str
    new_password: str = Field(min_length=8)


# Response schemas
class UserResponse(BaseModel):
    """User response model."""

    id: UUID
    email: str
    first_name: str
    last_name: str
    display_name: str | None
    avatar_path: str | None
    is_active: bool
    email_verified: bool
    timezone: str
    language: str
    theme: str
    created_at: datetime
    last_login_at: datetime | None

    model_config = {"from_attributes": True}


class TokenResponse(BaseModel):
    """Token response for login."""

    user: UserResponse
    csrf_token: str


class RoleResponse(BaseModel):
    """Role response model."""

    id: UUID
    name: str
    description: str
    is_system: bool

    model_config = {"from_attributes": True}


class PermissionResponse(BaseModel):
    """Permission response model."""

    id: UUID
    codename: str
    description: str

    model_config = {"from_attributes": True}


class RoleDetailResponse(RoleResponse):
    """Role with permissions."""

    permissions: list[PermissionResponse]
```

**Step 2: Run type check**

Run: `uv run mypy src/groundwork/auth/schemas.py`
Expected: Success

**Step 3: Commit**

```bash
git add src/groundwork/auth/schemas.py
git commit -m "feat: add auth Pydantic schemas"
```

---

## Task 9: Auth Dependencies

**Files:**
- Create: `src/groundwork/auth/dependencies.py`
- Create: `tests/auth/test_dependencies.py`

**Step 1: Write the failing test**

Create `tests/auth/test_dependencies.py`:
```python
"""Tests for auth dependencies."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from fastapi import HTTPException


@pytest.mark.asyncio
async def test_get_current_user_returns_user_from_valid_token() -> None:
    """get_current_user should return user when token is valid."""
    from groundwork.auth.dependencies import get_current_user
    from uuid import uuid4

    user_id = uuid4()
    mock_user = MagicMock()
    mock_user.id = user_id
    mock_user.is_active = True

    mock_request = MagicMock()
    mock_request.cookies = {"access_token": "valid.token.here"}

    mock_db = AsyncMock()
    mock_result = MagicMock()
    mock_result.scalar_one_or_none.return_value = mock_user
    mock_db.execute.return_value = mock_result

    with patch("groundwork.auth.dependencies.decode_token") as mock_decode:
        mock_decode.return_value = {"sub": str(user_id), "type": "access"}
        result = await get_current_user(mock_request, mock_db)

    assert result is mock_user


@pytest.mark.asyncio
async def test_get_current_user_raises_401_for_missing_token() -> None:
    """get_current_user should raise 401 when no token provided."""
    from groundwork.auth.dependencies import get_current_user

    mock_request = MagicMock()
    mock_request.cookies = {}

    mock_db = AsyncMock()

    with pytest.raises(HTTPException) as exc_info:
        await get_current_user(mock_request, mock_db)

    assert exc_info.value.status_code == 401


def test_require_permission_raises_403_when_permission_missing() -> None:
    """require_permission should raise 403 when user lacks permission."""
    from groundwork.auth.dependencies import require_permission

    mock_user = MagicMock()
    mock_user.role.has_permission.return_value = False

    checker = require_permission("users:create")

    with pytest.raises(HTTPException) as exc_info:
        checker(mock_user)

    assert exc_info.value.status_code == 403
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest tests/auth/test_dependencies.py -v`
Expected: FAIL

**Step 3: Write the implementation**

Create `src/groundwork/auth/dependencies.py`:
```python
"""Authentication dependencies for FastAPI."""

from typing import Annotated
from uuid import UUID

from fastapi import Depends, HTTPException, Request, status
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.orm import selectinload

from groundwork.auth.models import User
from groundwork.auth.utils import decode_token
from groundwork.core.database import get_db


async def get_current_user(
    request: Request,
    db: Annotated[AsyncSession, Depends(get_db)],
) -> User:
    """Get current authenticated user from access token cookie."""
    token = request.cookies.get("access_token")

    if not token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
        )

    payload = decode_token(token)
    if payload is None or payload.get("type") != "access":
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )

    user_id = payload.get("sub")
    if not user_id:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token payload",
        )

    result = await db.execute(
        select(User)
        .options(selectinload(User.role))
        .where(User.id == UUID(user_id))
    )
    user = result.scalar_one_or_none()

    if user is None or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="User not found or inactive",
        )

    return user


def require_permission(permission: str):
    """Dependency that checks if user has a specific permission."""
    def checker(user: Annotated[User, Depends(get_current_user)]) -> User:
        if not user.role.has_permission(permission):
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Permission denied: {permission}",
            )
        return user
    return checker


# Type alias for common dependency
CurrentUser = Annotated[User, Depends(get_current_user)]
```

**Step 4: Run test to verify it passes**

Run: `uv run pytest tests/auth/test_dependencies.py -v`
Expected: PASS (3 tests)

**Step 5: Run type check**

Run: `uv run mypy src/groundwork/auth/dependencies.py`
Expected: Success

**Step 6: Commit**

```bash
git add src/groundwork/auth/dependencies.py tests/auth/test_dependencies.py
git commit -m "feat: add auth dependencies for FastAPI"
```

---

## Task 10: Auth Service

**Files:**
- Create: `src/groundwork/auth/services.py`
- Create: `tests/auth/test_services.py`

**Step 1: Write the failing test**

Create `tests/auth/test_services.py`:
```python
"""Tests for auth service."""

import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from datetime import datetime, timezone


@pytest.mark.asyncio
async def test_auth_service_login_returns_tokens() -> None:
    """AuthService.login should return access and refresh tokens."""
    from groundwork.auth.services import AuthService

    mock_db = AsyncMock()
    mock_user = MagicMock()
    mock_user.id = "user-id-123"

    with patch("groundwork.auth.services.LocalAuthProvider") as mock_provider_class:
        mock_provider = AsyncMock()
        mock_provider.authenticate.return_value = mock_user
        mock_provider_class.return_value = mock_provider

        service = AuthService(mock_db)
        result = await service.login("test@example.com", "password123")

    assert result is not None
    assert "access_token" in result
    assert "refresh_token" in result
    assert result["user"] is mock_user


@pytest.mark.asyncio
async def test_auth_service_login_returns_none_for_invalid_credentials() -> None:
    """AuthService.login should return None for invalid credentials."""
    from groundwork.auth.services import AuthService

    mock_db = AsyncMock()

    with patch("groundwork.auth.services.LocalAuthProvider") as mock_provider_class:
        mock_provider = AsyncMock()
        mock_provider.authenticate.return_value = None
        mock_provider_class.return_value = mock_provider

        service = AuthService(mock_db)
        result = await service.login("test@example.com", "wrongpassword")

    assert result is None
```

**Step 2: Run test to verify it fails**

Run: `uv run pytest tests/auth/test_services.py -v`
Expected: FAIL

**Step 3: Write the implementation**

Create `src/groundwork/auth/services.py`:
```python
"""Authentication service."""

import secrets
from datetime import datetime, timedelta, timezone
from typing import Any

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from groundwork.auth.models import RefreshToken, User
from groundwork.auth.providers.local import LocalAuthProvider
from groundwork.auth.utils import (
    create_access_token,
    create_refresh_token,
    decode_token,
    hash_password,
)


class AuthService:
    """Service for authentication operations."""

    def __init__(self, db: AsyncSession) -> None:
        """Initialize with database session."""
        self.db = db
        self.provider = LocalAuthProvider(db)

    async def login(self, email: str, password: str) -> dict[str, Any] | None:
        """Authenticate user and return tokens."""
        user = await self.provider.authenticate(email, password)
        if user is None:
            return None

        # Update last login
        user.last_login_at = datetime.now(timezone.utc)

        # Generate tokens
        access_token = create_access_token(str(user.id))
        refresh_token = create_refresh_token(str(user.id))

        # Store refresh token hash
        token_record = RefreshToken(
            user_id=user.id,
            token_hash=hash_password(refresh_token),
            expires_at=datetime.now(timezone.utc) + timedelta(days=7),
        )
        self.db.add(token_record)
        await self.db.flush()

        # Generate CSRF token
        csrf_token = secrets.token_urlsafe(32)

        return {
            "access_token": access_token,
            "refresh_token": refresh_token,
            "csrf_token": csrf_token,
            "user": user,
        }

    async def logout(self, refresh_token: str) -> bool:
        """Revoke refresh token."""
        payload = decode_token(refresh_token)
        if payload is None or payload.get("type") != "refresh":
            return False

        # Find and revoke the token
        # Note: In production, you'd want to find by token hash
        result = await self.db.execute(
            select(RefreshToken)
            .where(RefreshToken.user_id == payload["sub"])
            .where(RefreshToken.revoked_at.is_(None))
        )
        tokens = result.scalars().all()

        for token in tokens:
            token.revoked_at = datetime.now(timezone.utc)

        await self.db.flush()
        return True

    async def refresh_access_token(self, refresh_token: str) -> dict[str, Any] | None:
        """Generate new access token from refresh token."""
        payload = decode_token(refresh_token)
        if payload is None or payload.get("type") != "refresh":
            return None

        user_id = payload.get("sub")
        if not user_id:
            return None

        # Verify user exists and is active
        from uuid import UUID
        result = await self.db.execute(
            select(User).where(User.id == UUID(user_id))
        )
        user = result.scalar_one_or_none()

        if user is None or not user.is_active:
            return None

        # Generate new access token
        access_token = create_access_token(str(user.id))
        csrf_token = secrets.token_urlsafe(32)

        return {
            "access_token": access_token,
            "csrf_token": csrf_token,
            "user": user,
        }
```

**Step 4: Run test to verify it passes**

Run: `uv run pytest tests/auth/test_services.py -v`
Expected: PASS (2 tests)

**Step 5: Run type check**

Run: `uv run mypy src/groundwork/auth/services.py`
Expected: Success

**Step 6: Commit**

```bash
git add src/groundwork/auth/services.py tests/auth/test_services.py
git commit -m "feat: add AuthService for login/logout/refresh"
```

---

*Continued in next tasks...*

The remaining tasks will cover:
- Task 11-13: Auth API routes (login, logout, refresh, password reset)
- Task 14-15: User management routes
- Task 16-17: Profile and role routes
- Task 18: Setup middleware
- Task 19-20: Setup wizard routes
- Task 21: Default roles and permissions seeding
- Task 22-24: CSS structure and base templates
- Task 25-27: Component templates
- Task 28-30: Page templates
- Task 31: Test factories
- Task 32: Final verification
